---
title: "COVID-19 Project: RSKC Analysis for Gene Expression"
author: "Rachel Kwan and Jonathan Zaslavsky"
date: "`r Sys.Date()`"
output: pdf_document
---

## Relevant Packages
```{r message=FALSE, warning=FALSE}
# Load packages
library(here) # To read in data from directory
library(tidyverse) # For ggplot2, dplyr
library(magrittr) # For set_colnames() and set_rownames()
library(ggpubr) # For making publication-ready plots based on ggplot
library(RSKC) # For RSKC clustering
library(Rtsne) # To run t-SNE (dimensionality reduction)
library(factoextra) # For fviz_nbclust() and clustering analysis/visualization
library(reshape2) # For melt()
library(RColorBrewer) # For color palettes
library(viridis) # For color palettes
library(gplots) # For heatmap.2()
library(dendextend) # For manipulating visual appearance of dendrograms
library(ggdendro) # For constructing dendrograms based on ggplot
library(R.devices) # For devEval() to save pdf of loess plots
library(ggforce) # For facet_wrap_paginate()

# Set the seed
set.seed(72613)
```

## Import and Prepare Dataset
```{r}
# Load full dataset
all_expression <- read.csv(here("Data", "Kang Data 17528 genes 1340 cases.csv")) 

# List of 12 SARS-CoV-2 receptors:
# ANPEP, ENPEP, ACE2, DPP4, SCARB1, AXL, NRP1, NRP2, CLEC4M, CLEC4G, CD209, CEACAM1
# List of 4 SARS-CoV-2 proteases:
# TMPRSS2, FURIN, ADAM17, CTSL
# List of 13 SARS-CoV-2 integrins:
# ITGB3, ITGA5, ITGB1, ITGB6, ITGAV, ITGB8, ITGB2, ITGA2B, ITGAM, ITGAL, ITGA3, ITGA8, ITGB5

# Create a vector containing all of the names of the 29 genes of interest,
# and sort into alphabetical order.
genes <- c('ANPEP', 'ENPEP', 'ACE2', 'DPP4', 'SCARB1', 'AXL', 'NRP1', 'NRP2', 'CLEC4M', 
           'CLEC4G', 'CD209', 'CEACAM1', 'TMPRSS2', 'FURIN', 'ADAM17', 'CTSL1', 'ITGB3', 
           'ITGA5', 'ITGB1', 'ITGB6', 'ITGAV', 'ITGB8', 'ITGB2', 'ITGA2B', 'ITGAM', 
           'ITGAL', 'ITGA3', 'ITGA8', 'ITGB5') %>%
  sort()

# Define a vector containing the 16 brain regions of interest (ordered alphabetically).
regions_16 <- c('A1C', 'AMY', 'CBC', 'DFC', 'HIP', 'IPC', 'ITC', 'M1C', 'MD', 'MFC', 'OFC',
             'S1C', 'STC', 'STR', 'V1C', 'VFC')

# Select desired columns from original full data frame, then filter to keep only 
# desired regions.
all_expression <- all_expression %>%
  select(Sample, Region, Years, genes) %>%
  filter(Region %in% regions_16)

# Create a data frame grouping each observation by the brain region and 
# computing the average expression of each gene within a given brain region. 
gene_expression <- all_expression %>% 
  group_by(Region) %>%
  summarize_at(vars(all_of(genes)), mean) %>%
  rename(Brain.Region = Region)

# Use the brain regions to name the rows and remove the brain region column.
myExpression <- gene_expression %>%
  column_to_rownames("Brain.Region")
```

## Perform Robust and Sparse K-Means Clustering (RSKC) and t-SNE Together

This while loop contains sections for RSKC, elbow plot, obtaining weighted data, and tSNE. Desmond's code was used as template for this while loop, in particular, for the RSKC and tSNE sections.

```{r}
set.seed(72613)

while (T) {
  
  # Assign desired number of clusters to 'clust_vect'.
  clust_vect <- c(3,4,5,6)
  
  # Assign an empty list to 'rskc_list'.
  rskc_list <- list()
  
  # Assign 6 colours to 'col_vect'.
  col_vect <- c("#FF0000",
                "#0000FF",
                "#00FF00",
                "#A020F0",
                "#FFA500",
                "#FFFF00")
  
  # Assign a value of 0 to 'counter'.
  counter <- 0
  
  # Assign an empty list to 'tsne_list'.
  tsne_list <- list()
  
  # Assign an empty list to 'weight_list'.
  weight_list <- list()
  
  # For 'i' -- the current number of clusters -- in 'clust_vect'...
  for (i in clust_vect) {
    # i = 3
    # Increment 'counter' with a value of 1.
    counter = counter + 1
    
    ###### RSKC ######
    
    # Perform RSKC for whatever-the-value-of-'i'-is many clusters using 
    # 'myExpression', which has brain region as rows and gene_celltype as columns.
    # Assign RSKC's output as an entry in 'rskc_list'. 
    rskc_list[[counter]] <- RSKC(myExpression, 
                                 ncl = i,
                                 alpha = 0.1,
                                 L1 = sqrt(ncol(myExpression)))
    
    # Convert the row names of 'myExpression' to a column
    # called 'Brain.Region' and store it in 'gene_and_region'.
    gene_and_region <- myExpression %>% 
      rownames_to_column("Brain.Region")
    
    # For the current object in 'rskc_list' convert the cluster labels
    # into characters, and assign them to a new column called 'cluster_labels'
    # in 'gene_and_region'.  
    gene_and_region$cluster_labels <- rskc_list[[counter]]$labels %>% 
      as.character()
    
    # Order the weights for the current item in 'rskc_list' from largest
    # to smallest, extract the names of the genes in this order,
    # convert this object into a data frame, and store this info in
    # an object 'weight_df' in a column called 'gene'.
    weight_df <- sort(rskc_list[[counter]]$weights, 
                      decreasing = T) %>% 
      names() %>% 
      as.data.frame() %>% 
      rename('gene' = ".")
    
    # Assign the ordered weights for the current item in 'rskc_list' into
    # 'weight_df', in a column called 'weight', 
    weight_df$weight <- sort(rskc_list[[counter]]$weights,
                             decreasing = T) %>%
      unname() 
    
    # Impose a factor order on the contents of 'weight_df$gene' in 
    # the current order. 
    weight_df$gene <- factor(weight_df$gene,
                             weight_df$gene)
    
    # Create a bar graph of the RSKC weights for each gene ordered from
    # largest to smallest. Assign this graph to an object, 'weight_bars'.
    weight_bars <- weight_df %>% 
      ggplot(aes(x = gene, y = weight)) + 
      theme_classic() +
      geom_bar(stat = 'identity') +
      theme(axis.text.x = element_text(angle = 45, vjust = 0.6)) +
      scale_y_continuous(expand = c(0,0)) +
      ggtitle(paste0("RSKC Weights for K = ",i)) +
      xlab("") +
      ylab("Weights\n")
    
    # Assign 'weight_bars' as the current entry into 'weight_list'. 
    weight_list[[counter]] <- weight_bars
    
    ###### Apply weights from RSKC to myExpression ######
    
    # Create vector of the weights obtained from RSKC and assign them to 'weights'.
    # Make empty matrix 'weighted_expression' for new weighted exprression.
    weights <- as.matrix(rskc_list[[1]]$weights)
    
    # Multiply 'myExpression' columns containing gene_celltype by corresponding 
    # weights obtained from RSKC.
    weighted_expression <- sweep(t(myExpression), 
                                 MARGIN = 1, weights,
                                 `*`) %>% 
      t()
    
    ###### tSNE (on weighted data) ######
    
    # Run tsne on weighted expression scores, and assign to 'tsne'
    set.seed(72613)
    tsne <- Rtsne(weighted_expression, perplexity = 5)
    
    # Create new df 'tsne_out' which contains the two dimensions obtained from tSNE
    # and corresponding regions
    tsne_out <- tsne$Y %>%
      data.frame(gene_and_region$Brain.Region) %>%
      rename(Brain.Region = gene_and_region.Brain.Region,
             V1 = X1, V2 = X2) #rename column
    
    # Merge 'tsne_out' with 'gene_and_region' according
    # to their shared 'Brain.Region' column, and assign to 
    # 'tsne_genes_regions_clusts'. 
    tsne_genes_regions_clusts <- merge(tsne_out,
                                       gene_and_region,
                                       by = "Brain.Region")
    
    # Create a tSNE scatter plot where each point is colour-coded according to
    # its designated RSKC cluster and assign this figure to 'tsne_scatter'.
    tsne_scatter <- ggplot(tsne_genes_regions_clusts,
                           aes(V1,
                               V2,
                               fill = cluster_labels)) +
      geom_point(shape = 21, size = 3) + 
      scale_fill_manual(values = col_vect[1:i],
                        labels = 1:i,
                        name = "Cluster") +
      theme(axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.text.y = element_blank(),
            axis.ticks.y = element_blank(),
            panel.background = element_rect(fill = NA, 
                                            colour = "white"),
            panel.border = element_blank(),
            axis.line = element_line(),
            legend.position = 'bottom',
            legend.background = element_rect(fill = NA,
                                             colour = NA), 
            legend.title.align=0.5) +
      guides(fill=guide_legend(nrow = 2,
                               ncol = 4, 
                               byrow = TRUE)) +
      labs(x="V1", y="V2") 
    
    # Assign 'tsne_scatter' as an entry in 'tsne_list'.
    tsne_list[[counter]] <- tsne_scatter
    
  }
  
  # Break out of the while-loop when for-loop is done. 
  break
  
}
```

```{r, fig.align = 'center', fig.height = 6, fig.width = 6}
# Make figures for all the plots obtained from the while loop above
# i.e. the RSKC scatter plots, the RKSC weights, and elbow plot
ggarrange(tsne_list[[1]], tsne_list[[2]],
          tsne_list[[3]], tsne_list[[4]],
          ncol = 2,
          nrow = 2)
```

```{r, fig.align = 'center', fig.height = 12, fig.width = 16}
ggarrange(weight_list[[1]], weight_list[[2]],
          weight_list[[3]], weight_list[[4]],
          ncol = 2,
          nrow = 2)
```

\newpage

## RSKC (10 Runs)

This chunk serves as a snapshot of the RSKC over 10 runs (i.e. different set.seed values) in order to visualize the variation in cluster label assignments for each observation. The 10 runs were carried out for each of $K = 3, 4, 5, 6$.


```{r}
set.seed(72613)

while (T) {
  
  # Assign the values of 3, 4, 5, 6 to 'clust_vect'.
  clust_vect <- c(3,4,5,6)
  
  # Assign empty lists to 'rskc.results.list' and 'rskc.weighted.list'
  # to store the results and the RSKC weighted data frames that result
  # from the clustering.
  rskc_results_list = list()
  rskc_weighted_list = list()
  
  # Assign 7 colours to 'col_vect'.
  col_vect <- c("#FF0000",
                "#0000FF",
                "#00FF00",
                "#A020F0",
                "#FFA500",
                "#FFFF00",
                "#A65628")
  
  # Assign an empty list to 'tsne_list_3', 'tsne_list_4', 'tsne_list_5', 
  # and 'tsne_list_6'.
  tsne_list_3 <- list()
  tsne_list_4 <- list()
  tsne_list_5 <- list()
  tsne_list_6 <- list()
  
  # Assign an empty list to 'weight_list'.
  weight_list <- list()
  
  # Create empty data frames to store the cluster assignments and cluster weights 
  # for each of the 10 runs.
    rskc_region_labels_3 = data.frame("Region" = rownames(myExpression))
    rskc_region_labels_4 = data.frame("Region" = rownames(myExpression))
    rskc_region_labels_5 = data.frame("Region" = rownames(myExpression))
    rskc_region_labels_6 = data.frame("Region" = rownames(myExpression))
    rskc_region_weights = data.frame("Case" = colnames(myExpression))
    
  # For 'i' -- the current number of clusters -- in 'clust_vect'...
  for (i in clust_vect) {
    
    ###### RSKC (10 Runs) ######
    
    # Create a vector of seeds for all 10 runs.
    set.seed(72613)
    x = rdunif(10, a = 1, b = 1000000)
    
    for (counter in 1:10) {
      
      # Set the seed.
      set.seed(x[counter])
      
      # Perform RSKC for whatever-the-value-of-''-is many clusters using 
      # 'myFidelity', which has brain region as rows and gene_celltype as columns.
      # Assign RSKC's output as an entry in 'rskc_results_list'.
      rskc_results_list[[counter]] <- RSKC(myExpression, 
                                           alpha = 0.1, 
                                           ncl = i, 
                                           L1 = sqrt(ncol(myExpression)))
      
      # Use the following if statements to add the cluster assignments for run i to 
      # the corresponding 'rskc_region_labels_3', 'rskc_region_labels_4', 'rskc_region_labels_5',
      # or 'rskc_region_labels_6'.
      if (i == 3){
        rskc_region_labels_3[counter+1] <- rskc_results_list[[counter]]$labels
        colnames(rskc_region_labels_3)[counter+1] <- paste("Run_", counter, sep = "")
      }
      
      if (i == 4){
        rskc_region_labels_4[counter+1] <- rskc_results_list[[counter]]$labels
        colnames(rskc_region_labels_4)[counter+1] <- paste("Run_", counter, sep = "")
      }
      
      if (i == 5){
        rskc_region_labels_5[counter+1] <- rskc_results_list[[counter]]$labels
        colnames(rskc_region_labels_5)[counter+1] <- paste("Run_", counter, sep = "")
      }
      
      if (i == 6){
        rskc_region_labels_6[counter+1] <- rskc_results_list[[counter]]$labels
        colnames(rskc_region_labels_6)[counter+1] <- paste("Run_", counter, sep = "")
      }
      
      # Add the variable weights for run i to the 'rskc_region_weights'
      rskc_region_weights[counter+1] <- rskc_results_list[[counter]]$weights
      colnames(rskc_region_weights)[counter+1] <- paste("Run_", counter, sep = "")
      
      # For the current object in 'rskc_list' convert the cluster labels
      # into characters, and assign them to a new column called 'cluster_labels'
      # in 'gene_expression'.  
      gene_expression$cluster_labels <- rskc_results_list[[counter]]$labels %>% 
        as.character()
     
      ###### Apply weights from RSKC to myExpression ######
      
      # Create vector of the weights obtained from RSKC and assign them to 'weights'.
      # Make empty matrix 'weighted_expression' for new weighted expression.
      weights <- as.matrix(rskc_results_list[[1]]$weights)
      
      # Multiply 'myExpression' columns containing gene_celltype by corresponding 
      # weights obtained from RSKC.
      weighted_expression <- sweep(t(myExpression), 
                                 MARGIN = 1, weights, `*`) %>%  
        t()
      
      ###### tSNE (on weighted data) ######
      
      # Run tsne on weighted expression scores, and assign to 'tsne'
      set.seed(72613)
      tsne <- Rtsne(weighted_expression, perplexity = 5)
      
      # Create new df 'tsne_out' which contains the two dimensions obtained from tSNE
      # and corresponding regions
      tsne_out <- tsne$Y %>%
        data.frame(gene_expression$Brain.Region) %>%
        rename(Brain.Region = gene_expression.Brain.Region, 
               V1 = X1, 
               V2 = X2) #rename columns
      
      # Merge 'tsne_out' with 'gene_expression' according
      # to their shared 'Brain.Region' column, and assign to 
      # 'tsne_genes_regions_clusts'. 
      tsne_genes_regions_clusts <- merge(tsne_out,
                                         gene_expression,
                                         by = "Brain.Region")
      
      # Create a tSNE scatter plot where each point is colour-coded according to
      # its designated RSKC cluster and assign this figure to 'tsne_scatter'.
      tsne_scatter <- ggplot(tsne_genes_regions_clusts,
                             aes(V1,
                                 V2,
                                 fill = cluster_labels)) +
        geom_point(shape = 21, size = 3) + 
        scale_fill_manual(values = col_vect[1:i],
                          labels = 1:i,
                          name = "Cluster") +
        theme(axis.text.x = element_blank(),
              axis.ticks.x = element_blank(),
              axis.text.y = element_blank(),
              axis.ticks.y = element_blank(),
              panel.background = element_rect(fill = NA, 
                                              colour = "white"),
              panel.border = element_blank(),
              axis.line = element_line(),
              legend.position = 'bottom',
              legend.background = element_rect(fill = NA,
                                               colour = NA), 
              legend.title.align=0.5) +
        guides(fill=guide_legend(nrow = 2,
                                 ncol = 4, 
                                 byrow = TRUE)) +
        labs(x="V1", y="V2") 
      
      # Use if statements to assign 'tsne_scatter' as an entry in 'tsne_list_3',
      # 'tsne_list_4', 'tsne_list_5', or 'tsne_list_6 depending on the current i.
      if (i == 3){
        tsne_list_3[[counter]] <- tsne_scatter
      }
      
      if (i == 4){
        tsne_list_4[[counter]] <- tsne_scatter
      }
      
      if (i == 5){
        tsne_list_5[[counter]] <- tsne_scatter
      }
      
      if (i == 6){
        tsne_list_6[[counter]] <- tsne_scatter
      }
      
    } 
    
  }
  
  # Break out of the while-loop when for-loop is done. 
  break
  
}
```

```{r, echo = FALSE, fig.align = 'center', fig.height = 14, fig.width = 6}
# Create 5x2 figure for the 10 scatter plots using K = 5 for RSKC.
ggarrange(tsne_list_3[[1]], tsne_list_3[[2]],
          tsne_list_3[[3]], tsne_list_3[[4]],
          tsne_list_3[[5]], tsne_list_3[[6]],
          tsne_list_3[[7]], tsne_list_3[[8]],
          tsne_list_3[[9]], tsne_list_3[[10]],
          ncol = 2,
          nrow = 5)
```

```{r, echo = FALSE, fig.align = 'center', fig.height = 14, fig.width = 6}
# Create 5x2 figure for the 10 scatter plots using  K = 3 for RSKC.
ggarrange(tsne_list_4[[1]], tsne_list_4[[2]],
          tsne_list_4[[3]], tsne_list_4[[4]],
          tsne_list_4[[5]], tsne_list_4[[6]],
          tsne_list_4[[7]], tsne_list_4[[8]],
          tsne_list_4[[9]], tsne_list_4[[10]],
          ncol = 2,
          nrow = 5)
```

```{r, echo = FALSE, fig.align = 'center', fig.height = 14, fig.width = 6}
# Create 5x2 figure for the 10 scatter plots using  K = 3 for RSKC.
ggarrange(tsne_list_5[[1]], tsne_list_5[[2]],
          tsne_list_5[[3]], tsne_list_5[[4]],
          tsne_list_5[[5]], tsne_list_5[[6]],
          tsne_list_5[[7]], tsne_list_5[[8]],
          tsne_list_5[[9]], tsne_list_5[[10]],
          ncol = 2,
          nrow = 5)
```

```{r, echo = FALSE, fig.align = 'center', fig.height = 14, fig.width = 6}
# Create 5x2 figure for the 10 scatter plots using K = 4 for RSKC.
ggarrange(tsne_list_6[[1]], tsne_list_6[[2]],
          tsne_list_6[[3]], tsne_list_6[[4]],
          tsne_list_6[[5]], tsne_list_6[[6]],
          tsne_list_6[[7]], tsne_list_6[[8]],
          tsne_list_6[[9]], tsne_list_6[[10]],
          ncol = 2,
          nrow = 5)
```

## RSKC (100 Runs)

Having previously selected the number of clusters to use for RSKC (i.e. 6), this portion of the code aims to evaluate the proportion of brain regions clustered together over 100 runs (i.e. 100 different set.seed values). The code is derived from previous work (i.e. Keon and Brendan).

```{r}
# Create empty lists to store the results and the RSKC weighted data frames 
# that result from the clustering.
rskc.results.list = list()
rskc.weighted.list = list()

# Create empty data frames to store the cluster assignments and cluster weights 
# for each of the 100 runs.
rskc.region.labels = data.frame("Region" = rownames(myExpression))
rskc.region.weights = data.frame("Case" = colnames(myExpression))

# Create a vector of seeds for all 100 runs.
set.seed(72613)
x = rdunif(100, a = 1, b = 1000000)

for (i in 1:100) {
  
  # Set the seed.
  set.seed(x[i])
  
  # Perform RSKC clustering on the data; the number of clusters is selected
  # a priori.
  rskc.results.list[[i]] = RSKC(myExpression, 
                                alpha = 0.1, 
                                ncl = 3, #change number of clusters
                                L1 = sqrt(ncol(myExpression)))
  
  # Add the cluster assignments for run i to the 'rskc.region.labels'.
  rskc.region.labels[i+1] = rskc.results.list[[i]]$labels
  colnames(rskc.region.labels)[i+1] = paste("Run_", i, sep = "")
  
  # Add the variable weights for run i to the 'rskc.region.weights'
  rskc.region.weights[i+1] = rskc.results.list[[i]]$weights
  colnames(rskc.region.weights)[i+1] = paste("Run_", i, sep = "")
  
  # Create a list of data frames containing the clustering data multiplied by 
  # the corresponding RSKC variable weights.
  rskc.weighted.list[[i]] = sweep(myExpression, 2, 
                                  rskc.results.list[[i]]$weights, "*")
}
```

### Calculating Proportion of Times Brain Regions are Clustered Together
```{r}
# Transpose the data frame with the cluster labels from the 100 runs.
rskc.region.labels.t <-  rskc.region.labels %>%
  column_to_rownames("Region") %>%
  t() %>%
  data.frame()

# Create an empty 16x16 data frame
rskc.cluster.regions.wide <-  data.frame(matrix(ncol = 16, nrow = 16)) %>%
  # Set the column and row names as the regions (ordered alphabetically)
  set_colnames(regions) %>%
  set_rownames(regions)

# Add in the number of matches for each ith row/jth column combination to 
# create the adjacency matrix.
for (i in 1:length(regions)) {
  for (j in 1:length(regions)) {
    
    rskc.cluster.regions.wide[i,j] = sum(rskc.region.labels.t[[regions[i]]] == rskc.region.labels.t[[regions[j]]])
    
  }
}

# Convert the adjacency matrix to long format for various plotting purposes
rskc.cluster.regions.long <-  rskc.cluster.regions.wide %>%
  # Give the region row names their own column
  rownames_to_column("Region_1") %>%
  # Lengthen the data with melt() so we have three columns: 
  # Region_1, Region_2 and the total number of matches.
  melt(id.vars = "Region_1", variable.name = "Region_2", value.name = "Matches") %>%
  # Convert the number of matches to a proportion
  mutate(Matches = Matches / 100)
```

### Heat Maps to Visualize Proportion of Shared Clusters
#### Unclustered Heat Map
```{r, fig.align = 'center', fig.height = 5, fig.width = 7}
# Factor the regions with levels corresponding to the specified brain region
# names from the 'regions' vector.
region.rskc.cluster.matches.ordered <-  rskc.cluster.regions.long %>%
  # Factor Region_1
  mutate(Region_1 = factor(Region_1, levels = regions)) %>%
  # Factor Region_2
  mutate(Region_2 = factor(Region_2, levels = regions))

# Plot the adjacency matrix as a heat map
ggplot(region.rskc.cluster.matches.ordered, aes(x = Region_1, y = Region_2, fill = Matches)) +
  geom_tile() +
  scale_fill_gradientn(colours = brewer.pal(n = 9, name = "YlOrRd")) +
  labs(x = NULL, 
       y = NULL, 
       fill = "Proportion of Matches on \n100 RSKC Runs") +
  theme_minimal() +
  theme(panel.border = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(colour = "black", angle = 45),
        axis.text.y = element_text(colour = "black"),
        axis.ticks = element_blank())
```

#### Hierarchical Clustered Heat Map
```{r, fig.align = 'center', fig.height = 5, fig.width = 7}
# Convert all values in the 'rskc.cluster.regions.wide' matrix into 
# proportions.
rskc.region.prop <- apply(rskc.cluster.regions.wide, 2, function(x) return(x/100)) %>% 
  as.matrix()

# Assign a dendrogram for the matrix of matched clustering of RSKC regions.
rskc_dendro <- set(as.dendrogram(hclust(dist(rskc.region.prop))), "branches_lwd", 3) %>%
  reorder(1:20)

# Define a colour 'ylOrRd' from brewer palette.
ylOrRd <- colorRampPalette(brewer.pal(n = 9, name = "YlOrRd"))

heatmap.2(rskc.region.prop, 
          scale = "none", 
          col = ylOrRd(100),
          Rowv = rskc_dendro,
          Colv = rskc_dendro,
          key = TRUE,
          key.xlab = "Proportion of Matches on \n 100 RSKC Runs",
          trace = "none", # Remove the histogram trace from heat map
          density.info = "none", # Remove the histogram from color key
          srtCol = 45, # Rotate column labels on heat map
          margins = c(5, 10),
          key.xtickfun = function(){
            breaks = pretty(parent.frame()$breaks)
            breaks = breaks[c(1, length(breaks))]
            list(at = parent.frame()$scale01(breaks),
                 labels = breaks)
          }
          )
```

### K = 4 Dendrogram-wrapped Heat Map

```{r, echo = FALSE, fig.align = 'center', fig.width = 7, fig.height = 5}
# Create empty lists to store the results and the RSKC weighted data frames 
# that result from the clustering.
rskc.results.list = list()
rskc.weighted.list = list()

# Create empty data frames to store the cluster assignments and cluster weights 
# for each of the 100 runs.
rskc.region.labels = data.frame("Region" = rownames(myExpression))
rskc.region.weights = data.frame("Case" = colnames(myExpression))

# Create a vector of seeds for all 100 runs.
set.seed(72613)
x = rdunif(100, a = 1, b = 1000000)

for (i in 1:100) {
  
  # Set the seed.
  set.seed(x[i])
  
  # Perform RSKC clustering on the data; the number of clusters is selected
  # a priori.
  rskc.results.list[[i]] = RSKC(myExpression, 
                                alpha = 0.1, 
                                ncl = 4, #change number of clusters
                                L1 = sqrt(ncol(myExpression)))
  
  # Add the cluster assignments for run i to the 'rskc.region.labels'.
  rskc.region.labels[i+1] = rskc.results.list[[i]]$labels
  colnames(rskc.region.labels)[i+1] = paste("Run_", i, sep = "")
  
  # Add the variable weights for run i to the 'rskc.region.weights'
  rskc.region.weights[i+1] = rskc.results.list[[i]]$weights
  colnames(rskc.region.weights)[i+1] = paste("Run_", i, sep = "")
  
  # Create a list of data frames containing the clustering data multiplied by 
  # the corresponding RSKC variable weights.
  rskc.weighted.list[[i]] = sweep(myExpression, 2, 
                                  rskc.results.list[[i]]$weights, "*")
}

# Transpose the data frame with the cluster labels from the 100 runs.
rskc.region.labels.t <-  rskc.region.labels %>%
  column_to_rownames("Region") %>%
  t() %>%
  data.frame()

# Create an empty 16x16 data frame
rskc.cluster.regions.wide <-  data.frame(matrix(ncol = 16, nrow = 16)) %>%
  # Set the column and row names as the regions (ordered alphabetically)
  set_colnames(regions) %>%
  set_rownames(regions)

# Add in the number of matches for each ith row/jth column combination to 
# create the adjacency matrix.
for (i in 1:length(regions)) {
  for (j in 1:length(regions)) {
    
    rskc.cluster.regions.wide[i,j] = sum(rskc.region.labels.t[[regions[i]]] == rskc.region.labels.t[[regions[j]]])
    
  }
}

# Convert the adjacency matrix to long format for various plotting purposes
rskc.cluster.regions.long <-  rskc.cluster.regions.wide %>%
  # Give the region row names their own column
  rownames_to_column("Region_1") %>%
  # Lengthen the data with melt() so we have three columns: 
  # Region_1, Region_2 and the total number of matches.
  melt(id.vars = "Region_1", variable.name = "Region_2", value.name = "Matches") %>%
  # Convert the number of matches to a proportion
  mutate(Matches = Matches / 100)

# Convert all values in the 'rskc.cluster.regions.wide' matrix into 
# proportions.
rskc.region.prop <- apply(rskc.cluster.regions.wide, 2, function(x) return(x/100)) %>% 
  as.matrix()

# Assign a dendrogram for the matrix of matched clustering of RSKC regions.
rskc_dendro <- set(as.dendrogram(hclust(dist(rskc.region.prop))), "branches_lwd", 3) %>%
  reorder(1:20)

# Define a colour 'ylOrRd' from brewer palette.
ylOrRd <- colorRampPalette(brewer.pal(n = 9, name = "YlOrRd"))

heatmap.2(rskc.region.prop, 
          scale = "none", 
          col = ylOrRd(100),
          Rowv = rskc_dendro,
          Colv = rskc_dendro,
          key = TRUE,
          key.xlab = "Proportion of Matches on \n 100 RSKC Runs",
          trace = "none", # Remove the histogram trace from heat map
          density.info = "none", # Remove the histogram from color key
          srtCol = 45, # Rotate column labels on heat map
          margins = c(5, 10),
          key.xtickfun = function(){
            breaks = pretty(parent.frame()$breaks)
            breaks = breaks[c(1, length(breaks))]
            list(at = parent.frame()$scale01(breaks),
                 labels = breaks)
          }
          )
```

### K = 5 Dendrogram-wrapped Heat Map

```{r, echo = FALSE, fig.align = 'center', fig.width = 7, fig.height = 5}
# Create empty lists to store the results and the RSKC weighted data frames 
# that result from the clustering.
rskc.results.list = list()
rskc.weighted.list = list()

# Create empty data frames to store the cluster assignments and cluster weights 
# for each of the 100 runs.
rskc.region.labels = data.frame("Region" = rownames(myExpression))
rskc.region.weights = data.frame("Case" = colnames(myExpression))

# Create a vector of seeds for all 100 runs.
set.seed(72613)
x = rdunif(100, a = 1, b = 1000000)

for (i in 1:100) {
  
  # Set the seed.
  set.seed(x[i])
  
  # Perform RSKC clustering on the data; the number of clusters is selected
  # a priori.
  rskc.results.list[[i]] = RSKC(myExpression, 
                                alpha = 0.1, 
                                ncl = 5, #change number of clusters
                                L1 = sqrt(ncol(myExpression)))
  
  # Add the cluster assignments for run i to the 'rskc.region.labels'.
  rskc.region.labels[i+1] = rskc.results.list[[i]]$labels
  colnames(rskc.region.labels)[i+1] = paste("Run_", i, sep = "")
  
  # Add the variable weights for run i to the 'rskc.region.weights'
  rskc.region.weights[i+1] = rskc.results.list[[i]]$weights
  colnames(rskc.region.weights)[i+1] = paste("Run_", i, sep = "")
  
  # Create a list of data frames containing the clustering data multiplied by 
  # the corresponding RSKC variable weights.
  rskc.weighted.list[[i]] = sweep(myExpression, 2, 
                                  rskc.results.list[[i]]$weights, "*")
}

# Transpose the data frame with the cluster labels from the 100 runs.
rskc.region.labels.t <-  rskc.region.labels %>%
  column_to_rownames("Region") %>%
  t() %>%
  data.frame()

# Create an empty 16x16 data frame
rskc.cluster.regions.wide <-  data.frame(matrix(ncol = 16, nrow = 16)) %>%
  # Set the column and row names as the regions (ordered alphabetically)
  set_colnames(regions) %>%
  set_rownames(regions)

# Add in the number of matches for each ith row/jth column combination to 
# create the adjacency matrix.
for (i in 1:length(regions)) {
  for (j in 1:length(regions)) {
    
    rskc.cluster.regions.wide[i,j] = sum(rskc.region.labels.t[[regions[i]]] == rskc.region.labels.t[[regions[j]]])
    
  }
}

# Convert the adjacency matrix to long format for various plotting purposes
rskc.cluster.regions.long <-  rskc.cluster.regions.wide %>%
  # Give the region row names their own column
  rownames_to_column("Region_1") %>%
  # Lengthen the data with melt() so we have three columns: 
  # Region_1, Region_2 and the total number of matches.
  melt(id.vars = "Region_1", variable.name = "Region_2", value.name = "Matches") %>%
  # Convert the number of matches to a proportion
  mutate(Matches = Matches / 100)

# Convert all values in the 'rskc.cluster.regions.wide' matrix into 
# proportions.
rskc.region.prop <- apply(rskc.cluster.regions.wide, 2, function(x) return(x/100)) %>% 
  as.matrix()

# Assign a dendrogram for the matrix of matched clustering of RSKC regions.
rskc_dendro <- set(as.dendrogram(hclust(dist(rskc.region.prop))), "branches_lwd", 3) %>%
  reorder(1:20)

# Define a colour 'ylOrRd' from brewer palette.
ylOrRd <- colorRampPalette(brewer.pal(n = 9, name = "YlOrRd"))

heatmap.2(rskc.region.prop, 
          scale = "none", 
          col = ylOrRd(100),
          Rowv = rskc_dendro,
          Colv = rskc_dendro,
          key = TRUE,
          key.xlab = "Proportion of Matches on \n 100 RSKC Runs",
          trace = "none", # Remove the histogram trace from heat map
          density.info = "none", # Remove the histogram from color key
          srtCol = 45, # Rotate column labels on heat map
          margins = c(5, 10),
          key.xtickfun = function(){
            breaks = pretty(parent.frame()$breaks)
            breaks = breaks[c(1, length(breaks))]
            list(at = parent.frame()$scale01(breaks),
                 labels = breaks)
          }
          )
```

### K = 6 Dendrogram-wrapped Heat Map

```{r, echo = FALSE, fig.align = 'center', fig.width = 7, fig.height = 5}
# Create empty lists to store the results and the RSKC weighted data frames 
# that result from the clustering.
rskc.results.list = list()
rskc.weighted.list = list()

# Create empty data frames to store the cluster assignments and cluster weights 
# for each of the 100 runs.
rskc.region.labels = data.frame("Region" = rownames(myExpression))
rskc.region.weights = data.frame("Case" = colnames(myExpression))

# Create a vector of seeds for all 100 runs.
set.seed(72613)
x = rdunif(100, a = 1, b = 1000000)

for (i in 1:100) {
  
  # Set the seed.
  set.seed(x[i])
  
  # Perform RSKC clustering on the data; the number of clusters is selected
  # a priori.
  rskc.results.list[[i]] = RSKC(myExpression, 
                                alpha = 0.1, 
                                ncl = 6, #change number of clusters
                                L1 = sqrt(ncol(myExpression)))
  
  # Add the cluster assignments for run i to the 'rskc.region.labels'.
  rskc.region.labels[i+1] = rskc.results.list[[i]]$labels
  colnames(rskc.region.labels)[i+1] = paste("Run_", i, sep = "")
  
  # Add the variable weights for run i to the 'rskc.region.weights'
  rskc.region.weights[i+1] = rskc.results.list[[i]]$weights
  colnames(rskc.region.weights)[i+1] = paste("Run_", i, sep = "")
  
  # Create a list of data frames containing the clustering data multiplied by 
  # the corresponding RSKC variable weights.
  rskc.weighted.list[[i]] = sweep(myExpression, 2, 
                                  rskc.results.list[[i]]$weights, "*")
}

# Transpose the data frame with the cluster labels from the 100 runs.
rskc.region.labels.t <-  rskc.region.labels %>%
  column_to_rownames("Region") %>%
  t() %>%
  data.frame()

# Create an empty 16x16 data frame
rskc.cluster.regions.wide <-  data.frame(matrix(ncol = 16, nrow = 16)) %>%
  # Set the column and row names as the regions (ordered alphabetically)
  set_colnames(regions) %>%
  set_rownames(regions)

# Add in the number of matches for each ith row/jth column combination to 
# create the adjacency matrix.
for (i in 1:length(regions)) {
  for (j in 1:length(regions)) {
    
    rskc.cluster.regions.wide[i,j] = sum(rskc.region.labels.t[[regions[i]]] == rskc.region.labels.t[[regions[j]]])
    
  }
}

# Convert the adjacency matrix to long format for various plotting purposes
rskc.cluster.regions.long <-  rskc.cluster.regions.wide %>%
  # Give the region row names their own column
  rownames_to_column("Region_1") %>%
  # Lengthen the data with melt() so we have three columns: 
  # Region_1, Region_2 and the total number of matches.
  melt(id.vars = "Region_1", variable.name = "Region_2", value.name = "Matches") %>%
  # Convert the number of matches to a proportion
  mutate(Matches = Matches / 100)

# Convert all values in the 'rskc.cluster.regions.wide' matrix into 
# proportions.
rskc.region.prop <- apply(rskc.cluster.regions.wide, 2, function(x) return(x/100)) %>% 
  as.matrix()

# Assign a dendrogram for the matrix of matched clustering of RSKC regions.
rskc_dendro <- set(as.dendrogram(hclust(dist(rskc.region.prop))), "branches_lwd", 3) %>%
  reorder(1:20)

# Define a colour 'ylOrRd' from brewer palette.
ylOrRd <- colorRampPalette(brewer.pal(n = 9, name = "YlOrRd"))

heatmap.2(rskc.region.prop, 
          scale = "none", 
          col = ylOrRd(100),
          Rowv = rskc_dendro,
          Colv = rskc_dendro,
          key = TRUE,
          key.xlab = "Proportion of Matches on \n 100 RSKC Runs",
          trace = "none", # Remove the histogram trace from heat map
          density.info = "none", # Remove the histogram from color key
          srtCol = 45, # Rotate column labels on heat map
          margins = c(5, 10),
          key.xtickfun = function(){
            breaks = pretty(parent.frame()$breaks)
            breaks = breaks[c(1, length(breaks))]
            list(at = parent.frame()$scale01(breaks),
                 labels = breaks)
          }
          )
```

## LOESS Curves

```{r z-score the data}
covid.gene.exp.numeric <- all_expression %>%
  #Make sure all expression values are numeric in R
  mutate_at(genes, as.numeric)

covid.gene.exp.zscore <- covid.gene.exp.numeric %>%
  # Group the data by region
  group_by(Region) %>%
  # 'Nest' the data (i.e. build data frames for each region inside of the data frame)
  nest() %>%
  # z-score the data separately for each gene and region
  mutate(data = map(.x = data, .f = ~.x %>% mutate_at(genes, scale))) %>%
  # Unnest the data
  unnest(cols = c(data))

# Get long version of z-scored data
covid.gene.exp.zscore.long <- covid.gene.exp.zscore %>%
  pivot_longer(cols = all_of(genes),
               names_to = "Gene",
               values_to = "Expression")
```

```{r fit loess curves for z-scored data}
covid.gene.exp.zscore.loess <- covid.gene.exp.zscore %>%
  # Use the melt function to put the data in long format
  melt(id.vars = c("Sample", "Region", "Years"), variable.name = "Gene", value.name = "Expression") %>%
  # Group by region and Gene, then nest the data
  group_by(Region, Gene) %>%
  nest() %>%
  # Fit a loess model for each gene and region
  mutate(loess.model = map(.x = data, ~loess(data = .x, formula = Expression ~ log2(Years)))) %>%
  # Find the min and max age value for each curve
  mutate(min = map(.x = data, .f = ~min(log2(.x$Years))),
         max = map(.x = data, .f = ~max(log2(.x$Years)))) %>%
  unnest(min) %>% unnest(max) %>%
  # Create a vector of 80 log2 age values for each curve
  mutate(age.values = map2(.x = min, .y = max, ~seq(.x, .y, (.y - .x)/79))) %>%
  # Extract the fitted LOESS expression values along this curve
  mutate(fitted.values = map2(.x = loess.model, .y = age.values,
                              ~data.frame("Years" = 2^(.y), 
                                          "Expression" = predict(.x, newdata = .y))))
```

```{r get fitted values of loess curves}
# Create a data frame with just the fitted values of the loess curves of the z-scored data
covid.gene.exp.zscore.loess.fitted = covid.gene.exp.zscore.loess %>%
  # Select necessary columns
  select(Region, Gene, fitted.values) %>%
  # Unnest the fitted values
  unnest(cols = c(fitted.values))
```

```{r save csv}
# Save the raw LOESS fitted value data as a csv
write.csv(covid.gene.exp.zscore.loess.fitted, 
          here::here("Data", 
                     "COVID Data - Zscored - Fitted LOESS Values for each Gene and Region.csv"),
          row.names = FALSE)
```

# Plot a test LOESS Curve

Test LOESS Curve for Z-scored (log2 transformed) Data
```{r}
test.raw = covid.gene.exp.zscore.long %>% 
  # Filter for only DPP4 expression values from the V1C
  filter(Gene == "DPP4", Region == "A1C")

ggplot(test.raw, aes(x = Years, y = Expression)) +
  # Add in shading in the background to separate pre-natal, infancy, childhood, and adulthood
  annotate("rect", xmin = 0, xmax = 40/52, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey40") +
  annotate("rect", xmin = 40/52, xmax = 92/52, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey60") +
  annotate("rect", xmin = 92/52, xmax = 40/52 + 18, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey80") +
  # Add in a dashed line to separate pre and post-natal
  geom_vline(aes(xintercept = 40/52), linetype = "dashed") +
  # Add in the LOESS curves
  geom_smooth(method = "loess", span = 0.7091, method.args = list(family = 'gaussian', degree = 2)) +
  # Add points
  geom_point(size = 1) +
  # Scale the x-axis by log2 and overwrite the labels
  scale_x_continuous(trans = "log2", 
                     breaks = c(0, 10/52, 20/52, 40/52, 40/52 + 2/12, 40/52 + 6/12, 92/52, 
                                40/52 + 2, 40/52 + 4, 40/52 + 8, 40/52 + 16, 40/52 + 32, 
                                40/52 + 64, 40/52 + 90),
                     labels = c("0 PCW", "10 PCW", "20 PCW", "0", "2 M", "6 M", "1 Y", 
                                "2 Y", "4 Y", "8 Y", "16 Y", "32 Y", "64 Y", "90 Y")) +
  # Separate the data into 16 panels for each region
  facet_wrap(~Region + Gene) +
  # Label the axes
  labs(x = "Age", y = "Lifespan Trajectory of Gene Expression") +
  # Change up the theme for aesthetics and clarity
  theme_bw() +
  theme(axis.text.x = element_text(angle= 270, size = 7),
        axis.text.y = element_text(size = 7),
        axis.title.y = element_text(size = 9),
        panel.grid = element_blank())

```

# Plot the LOESS Curves and Save As PDFs

PDF of LOESS Curves for Z-scored for 29 Genes by Region 
```{r message=FALSE, warning=FALSE}
# Create the plots and store them as loess.raw.zscore.stamp.collection
loess.raw.zscore.stamp.collection = ggplot(covid.gene.exp.zscore.long, 
                                           aes(x = Years, y = Expression)) +
  # Add in shading in the background to separate pre-natal, infancy, childhood, 
  # and adulthood
  annotate("rect", xmin = 0, xmax = 40/52, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey40") +
  annotate("rect", xmin = 40/52, xmax = 92/52, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey60") +
  annotate("rect", xmin = 92/52, xmax = 40/52 + 18, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey80") +
  # Add in a dashed line to separate pre and post-natal
  geom_vline(aes(xintercept = 40/52), linetype = "dashed") +
  # Add in the LOESS curves
  geom_smooth(method = "loess", span = 0.7091, method.args = list(family = 'gaussian', degree = 2)) +
  # Add points
  #geom_point(size = 1) +
  # Scale the x-axis by log2 and overwrite the labels
  scale_x_continuous(trans = "log2", 
                     breaks = c(0, 10/52, 20/52, 40/52, 40/52 + 2/12, 40/52 + 6/12, 92/52,
                                40/52 + 2, 40/52 + 4, 40/52 + 8, 40/52 + 16, 40/52 + 32,
                                40/52 + 64, 40/52 + 90),
                     labels = c("0 PCW", "10 PCW", "20 PCW", "0", "2 M", "6 M", "1 Y",
                                "2 Y", "4 Y", "8 Y", "16 Y", "32 Y", "64 Y", "90 Y")) +
  # Separate the data into 16 panels for each region
  facet_wrap(~Gene + Region) +
  # Label the axes
  labs(x = "Age", y = "Lifespan Trajectory of Gene Expression") +
  # Change up the theme for aesthetics and clarity
  theme_bw() +
  theme(axis.text.x = element_text(angle= 270, size = 7),
        axis.text.y = element_text(size = 7),
        axis.title.y = element_text(size = 9),
        panel.grid = element_blank())

# Determine how many pages we will need
num_pages = length(genes)

# Save the plots as a pdf
devEval(type = "pdf",
        path = here("Exploration"),
        name = "LOESS Curves of Non-Transformed Z Scored Expression for all 29 Genes By Region with SE no points",
        height = 9, 
        width = 9,
        expr = {
          for (j in 1:num_pages) {
            # Plot LOESS curve for each and facet wrap by gene
              print(loess.raw.zscore.stamp.collection + 
                      facet_wrap_paginate(vars(Gene, Region), 
                                          ncol = 4, nrow = 4, 
                                          page = j, scales = "free_y"))
            }
        })
```

PDF of LOESS Curves for Z-scored for 16 Regions by Gene 
```{r message=FALSE, warning=FALSE}
# Create the plots and store them as loess.raw.zscore.stamp.collection
loess.raw.zscore.stamp.collection = ggplot(covid.gene.exp.zscore.long, 
                                           aes(x = Years, y = Expression)) +
  # Add in shading in the background to separate pre-natal, infancy, childhood, 
  # and adulthood
  annotate("rect", xmin = 0, xmax = 40/52, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey40") +
  annotate("rect", xmin = 40/52, xmax = 92/52, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey60") +
  annotate("rect", xmin = 92/52, xmax = 40/52 + 18, ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "grey80") +
  # Add in a dashed line to separate pre and post-natal
  geom_vline(aes(xintercept = 40/52), linetype = "dashed") +
  # Add in the LOESS curves
  geom_smooth(method = "loess", span = 0.7091, method.args = list(family = 'gaussian', degree = 2)) +
  # Add points
  #geom_point(size = 1) +
  # Scale the x-axis by log2 and overwrite the labels
  scale_x_continuous(trans = "log2", 
                     breaks = c(0, 10/52, 20/52, 40/52, 40/52 + 2/12, 40/52 + 6/12, 92/52,
                                40/52 + 2, 40/52 + 4, 40/52 + 8, 40/52 + 16, 40/52 + 32,
                                40/52 + 64, 40/52 + 90),
                     labels = c("0 PCW", "10 PCW", "20 PCW", "0", "2 M", "6 M", "1 Y",
                                "2 Y", "4 Y", "8 Y", "16 Y", "32 Y", "64 Y", "90 Y")) +
  # Separate the data into 16 panels for each region
  facet_wrap(~Region + Gene) +
  # Label the axes
  labs(x = "Age", y = "Lifespan Trajectory of Gene Expression") +
  # Change up the theme for aesthetics and clarity
  theme_bw() +
  theme(axis.text.x = element_text(angle= 270, size = 7),
        axis.text.y = element_text(size = 7),
        axis.title.y = element_text(size = 9),
        panel.grid = element_blank())

# Determine how many pages we will need
# Each region needs two pages
num_pages = 2*length(regions)

# Save the plots as a pdf
devEval(type = "pdf",
        path = here("Exploration"),
        name = "LOESS Curves of Non-Transformed Z Scored Expression for all 16 Regions By Gene with SE no points",
        height = 9, 
        width = 9,
        expr = {
          for (j in 1:num_pages) {
            # Plot LOESS curve for each and facet wrap by gene
            if (j %% 2 == 1) {
              print(loess.raw.zscore.stamp.collection + 
                    facet_wrap_paginate(vars(Region, Gene), 
                                        ncol = 4, nrow = 4, 
                                        page = j, scales = "free_y"))
              }
            if (j %% 2 == 0) {
              print(loess.raw.zscore.stamp.collection + 
                    facet_wrap_paginate(vars(Region, Gene), 
                                        ncol = 4, nrow = 3, 
                                        page = j, scales = "free_y"))
            }
          }
        })
```

Ignore for now:

```{r}
# Create the plots and store them as loess.raw.stamp.collection
loess.raw.stamp.collection = ggplot(covid.gene.exp.raw.loess.fitted, 
                                    aes(x = Years, y = Expression, colour = Region)) +
  # Add in shading in the background to separate pre-natal, infancy, childhood, and adulthood
  annotate("rect", xmin = 0, xmax = 40/52, 
           ymin = -Inf, ymax = Inf, 
           alpha = 0.2, fill = "grey40") +
  annotate("rect", xmin = 40/52, xmax = 92/52, 
           ymin = -Inf, ymax = Inf,
           alpha = 0.2, fill = "grey60") +
  annotate("rect", xmin = 92/52, xmax = 40/52 + 18, 
           ymin = -Inf, ymax = Inf, 
           alpha = 0.2, fill = "grey80") +
  # Add in a dashed line to separate pre and post-natal
  geom_vline(aes(xintercept = 40/52), linetype = "dashed") +
  # Add in the LOESS curves
  geom_path(size = 1) +
  # Scale the x-axis by log2 and overwrite the labels
  scale_x_continuous(trans = "log2", 
                     breaks = c(0, 10/52, 20/52, 40/52, 40/52 + 2/12, 40/52 + 6/12, 92/52, 
                                40/52 + 2, 40/52 + 4, 40/52 + 8, 40/52 + 16, 40/52 + 32, 
                                40/52 + 64, 40/52 + 90),
                     labels = c("0 PCW", "10 PCW", "20 PCW", "0", "2 M", "6 M", "1 Y", 
                                "2 Y", "4 Y", "8 Y", "16 Y", "32 Y", "64 Y", "90 Y")) +
  # Separate the data into 37 panels for each gene
  facet_wrap(~Gene) +
  # Label the axes
  labs(x = "Age", y = "Lifespan Trajectory of Gene Expression") +
  # Change up the theme for aesthetics and clarity
  theme_bw() +
  theme(axis.text.x = element_text(angle= 270, size = 7),
        axis.text.y = element_text(size = 7),
        axis.title.y = element_text(size = 9),
        panel.grid = element_blank())
loess.raw.stamp.collection

# Determine how many pages we will need
# (We do this so we can plot the 37th gene separately on the last page)
num_pages = ceiling(length(genes)/4)
```

Save all of these plots in a single pdf file.

```{r}
# Save the plots as a pdf
devEval(type = "pdf",
        name = "Supplementary - LOESS Curves of Raw Expression for all 28 Genes in all 16 Regions",
        path = here::here("Exploration"),
        height = 7, 
        width = 9,
        expr = {
          for (j in 1:num_pages) {
              print(covid.gene.exp.raw.loess.fitted + facet_wrap_paginate(~Gene, 
                                                                          ncol = 2, 
                                                                          nrow = 2, 
                                                                          page = j, 
                                                                          scales = "free_y"))
          }
        })
```